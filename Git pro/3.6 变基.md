在Git中有在 Git 中整合来自不同分支的修改主要有两种方法：`merge` 以及 `rebase`。


> [!NOTE] rebase (变基)
> `git rebase` 是一个命令，它可以将一系列提交移动或组合到一个新的基础提交上。它最常用于特性分支工作流程中。从内容的角度来看，变基就是将您的分支从一个提交更改为另一个提交，使其看起来像您是从不同的提交创建了您的分支。在内部，Git 通过创建新的提交并将它们应用于指定的基础来实现这一点。
> 它有手动和交互两种模式

### 变基的基本操作
回顾以前的例子，会看到在开发任务分叉到两个不同分支，又进行了各自的提交。
![[Pasted image 20230526083220.png]]
Figure分叉的提交历史

整合分支最容易发方法是 `merge` 命令。它会把两个分支的最新快照(c3和c4)以及两者最近的共同祖先(c2)进行三方合并，合并的结果是生成一个新的快照。
![[Pasted image 20230526083612.png]]
Figure 通过合并操作来整合分叉的历史

但是，还有另一种方法：您可以获取引入的更改的补丁`C4`，然后将其重新应用到`C3`. 在 Git 中，这称为_变基_。可以使用 `rebase` 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。
 **例子**
 ```console
$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command
```
它的原理是首先找到这两个分支（即当前分支 `experiment`、变基操作的目标基底分支 `master`） 的最近共同祖先 `C2`，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 `C3`,最后以此将之前另存为临时文件的修改依序应用。
![[Pasted image 20230526084219.png]]
Figure  将 `C4` 中的修改变基到 `C3` 上

现在回到 `master` 分支，进行一次快进合并。

```console
$ git checkout master
$ git merge experiment
```
![[Pasted image 20230526084332.png]]










Figure  `master` 分支的快进合并

这时，`C4` 指向的快照就和[合并的例子](https://git-scm.com/book/zh/v2/ch00/ebasing-merging-example) 中的 `C5`  指向的快照一样了。这两种整合方法的最终结果没有任何区别，但是是变基使得交通历史更加整洁。
如果你检查一个 rebased 分支的日志，它看起来像一个线性历史：看起来所有的工作都是连续发生的，即使它最初是并行发生的。

无论是通过变基，还是通过第三方结合，整体的最终结果所指的快照开始终是一样的，只是不过提交史不同形了。
==变基是将一系列提供交照原有次依次应用到另一分支上，而结合是把最终结果结合在一起。=

### 更有趣的变基例子

在对两个分支持进行变化时，所产生的“重放”并不一定要在目标分支持上应用，你也可以指定另外一个分支持进行应用。
例如，将历史记录作为[一个主题分支从另一个主题分支中分离出来的历史记录。](https://git-scm.com/book/en/v2/ch00/rbdiag_e) 你进行了一次主题分支（serve）以向项目的添加一些服务器功能，然后进行提交。然后，您将其分支以进行客户端更改(client)并提交几次。最后，您回到服务器分支并进行了更多的提交
![[Pasted image 20230526085129.png]]
  
Figure 从一个主题支持里再分出一个主题支持的提交历史

假装你希望将`client`中的修改结合到主要支持并发布，但暂时并不想结合`server`并中的修改，因为他们还需要经过更全面的测试。
这时，你可以使用`git rebase`命令的`--onto`选项，选中在`client`分支里但不在`server`分支里的修改（即`C8`和`C9`），将它们在`master`分支上重新放出：

```console
$ git rebase --onto master server client
```

也就是，取出`client`分支，从`server`分支缺少的补丁中找出它，然后把这些补丁在`master`分支上重新放一遍，让`client`看起像直接基于 `master`修改一个样”。
![[Pasted image 20230526085512.png]]
Figure 截取主题支持上的另一个主题支持，然后变基到其他支持

现在可以快速进入并`master`分支持了。
```console
$ git checkout master
$ git merge client
```
![[Pasted image 20230526085550.png]]
Figure ：快速合并并`master`支持，使之包包含来自`client`分支持的修改

接下来若要将分支中的 `serve` 的修改也快速整合近来，这样能省去切换到分支再对其执行剩下操作的步骤，
```console
$ git rebase master server
```

如图[将`server`中的修改基础到`master`上面](https://git-scm.com/book/zh/v2/ch00/bdiag_h)所示，`server`中的代码被“继承”到`master`后面。
![[Pasted image 20230526090233.png]]

然后就可以快进并主要支持`master`了：

```console
$ git checkout master
$ git merge server
```
至此，`client`和`server`分支中的修改都已经整合到主要分支里了，你可以删掉这两个分支，最终提交历史会变图[最终的提交历史](https://git-scm.com/book/zh/v2/ch00/bdiag_i)中的样子：
```console
$ git branch -d client
$ git branch -d server
```
![[Pasted image 20230526090533.png]]

### 变基的风险

变基也并不完美无缺，要用它得遵守一条准则：==**不要对存在于您的存储库之外的提交进行重基，人们可能在这些提交的基础上进行了工作。**==
**Do not rebase commits that exist outside your repository and that people may have based work on.**

变基操作的实质是丢掉一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。如果你已经将提交推荐至某个仓库，而其他人也已经从该仓库拉取交并进行了后续工作，
然后你用`git rebase`重写这些提交，再把它们推上去，你的合作者将不得不重新合并他们的工作，当你试图把他们的工作pull回你的工作时，事情会变得混乱。

下面是在一个公开库上执行这个操作带来的问题，假设你从一个中央服务器克隆之后在它的基础上进行有一些开发。你的交流历史如图所示：
![[Pasted image 20230526091141.png]]
Figure 44. 克隆一个仓库，然后在它的基础上进行了一些开发

然后有人向中央服务器提供了一些修改，其中包括一次合并，你获取它并将新的远程分支合并到你的工作中，使你的历史记录看起来像这样:
![[Pasted image 20230526091319.png]]
Figure 45. 抓取别人的提交，合并到自己的开发分支
接下来这个人决定将合并操作回滚，改为使用变基，继而又用`git push --force`指令覆盖了服务器上的提交历史。服务器获取更新，会发现很多新的提交。
![[Pasted image 20230526091554.png]]
图 46. 有人推荐了经过改变基础的提交，并放弃了你的本地开发所基于的一些提交

现在，你和这个人的处境就变得十分尴尬，如果你使用`git pull` 命令 ，你将会创建一个合并提交

> [!NOTE] git pull
> 其作用是从远程 Git 存储库更新本地代码库。
> 它会将远程分支上的最新代码自动合并到本地代码库当前所在的分支上。如果本地分支与远程分支有不同的修改，可能会导致合并冲突，需要手动解决。
> 使用 "git pull" 命令可以让你的本地代码库与远程代码库保持同步。

最终的仓库如图：
![[Pasted image 20230526092114.png]]
Figure 47. 你将相同的内容又合并了一次，生成了一个新的提交

这时如果你执行`git log`命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会让人感觉混乱。
另外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被改变基扔的交又找回来了，这会让人感觉更加混乱。
很明显对方向并不想在交历史中看到`C4`的`C6`。，因为之前你的好伙伴就把这两个提通过变基丢弃了。

### 用变基解决变基

如果你**真的**遇到了类似的情况，Git 还有一些高级魔法可以帮助到你。做的就是检查你做了哪些修改，以及他们掩盖了哪些修改。
实际上，Git除了对整个提交交易计算SHA-1校试和以外，Git还计算基于提交时引入的补丁的校验和，即“patch-id”。

如果你把重写的工作拉下来，并把它放在你的合作伙伴新提交的工作上，Git通常可以成功地找出您的独特之处，并将它们应用到新分支上。

举个例子，如果遇到前面提出的[有人提出了经过改变基础的提供，而放弃了你的本地发展所基于的一些提出交情的那种](https://git-scm.com/book/zh/v2/ch00/_pre_merge_rebase_work)情况，如果我们不是执行合并，而执行`git rebase teamone/master`，Git 将会：

- 检查哪些是我们独有的（C2，C3，C4，C6，C7）
    
- 检查其中哪些提交不是合并操作的结果（C2，C3，C4）
    
- 检查哪些提交在对方外壳更新时并没有被纳入目标分支（只有C2和C3，因为为C4其实就是C4'）
    
- 把查到的这些提示交应用在`teamone/master`上面

从而我们将要得到与[你将相同的内容又结合了一次，生成了一个新的交](https://git-scm.com/book/zh/v2/ch00/_merge_rebase_work)中不同的结果，如图[中一个被改变基本后强制推送的分支上再执行变基准](https://git-scm.com/book/zh/v2/ch00/_rebase_rebase_work)。
![[Pasted image 20230526092629.png]]
Figure 48. 在一个被变基自然后强制推送的支持上再执行变基

要想上描述方法有效，还需要对方法在变基时确保`C4` 补丁和`C4`是差不多一样的。否则，rebase 将无法分辨出它是一个副本，并将添加另一个类似 c4 的补丁(这可能无法干净地应用，因为更改至少已经存在一些)。

在本例中另一种简单的方法是使用`git pull --rebase`命令而不是直接`git pull`。先`git fetch`，再`git rebase teamone/master`。

如果你习惯使用`git pull`，同时又希望默认使用选项`--rebase`，你可以执行这条语句`git config --global pull.rebase true`来更改`pull.rebase`默认配置。

如果只在本地电脑上进行提交，那将没有任何问题，
当和远程仓库进行交互时，如果您对已推送的提交进行了重新变基，同时没有其他人对其进行变基提交，也不会有问题。如果您对已经公开发布的提交进行了重新变基，而人们可能已经在这些提交的基础上进行了工作，那么您可能会遇到一些麻烦
如果你或你的伙伴在某种情况下决定要这样做，请一定要知道每个人执行`git pull --rebase`命令。

### 变基 vs. 合并

merge
对此的一种观点是，==存储库的提交历史记录是实际发生的事情的记录==。这是一份历史文件，本身就很有价值，不应该被篡改。从这个角度来看，更改提交历史几乎是亵渎神明;因为你在隐瞒事实真相。那么，如果有一系列混乱的合并提交怎么办?事情就是这样发生的，这个仓库应该为子孙后代保存下来。
rebase
相反的观点是，==提交历史记录是关于项目如何生成的故事==。你不会出版一本书的初稿，那么为什么要展示你凌乱的作品呢?当你着手一个项目时，你可能需要关于你所有错误的一份记录。但当你向世界展示你的作品时，你可能想要讲述一个更连贯的故事，讲述如何从a点到B点。这个阵营的人在将分支合并到主线分支中前使用`rebase` 和 `filter-branch` 这样的工具来重写他们的提交。以向未来的读者展示他们的故事。

到底结合还是变基好？这并没有一个简单的答案。 Git 是一个非常强大的工作具，它允许你对交代历史做许许多事，但每个团队、每个项目对这个的需求并不相同。当然你已经分别学习了双方的使用方法，相信你能够根据实际情况出明智能的选择。
总的原则是，只对尚未推荐或分享给其他人的本地修改操作改变基础操作清理历史，从不对已推荐至别处的提供执行变基操作，这样，你才能享受到两种方式带来的便利。